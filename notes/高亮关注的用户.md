# 高亮关注的用户

- 储存关注用户的数字 id 列表
- 需要保存用户的数字 id，以区分用户可能切换多个 pixiv 账户的情况
- 需要储存每次更新时的时间戳，以便实现定时更新以及过期失效等功能
- 应该在合适的时候更新关注列表

数据格式如下：

```ts
{
  /** 指示这个对象属于哪个用户 id **/
  user: string
  /** 此用户的关注用户的 id 列表 **/
  following: string[]
  /** 此用户公开关注的用户数量 **/
  publicTotal: number
  /** 此用户私密关注的用户数量 **/
  privateTotal: number
  /** 最后一次更新数据的时间戳 **/
  time: number
}[]
```

有了关注列表之后，查找页面上所有的用户链接，提取用户 id 进行判断。如果关注了该用户，则为这个元素添加特定的样式。

## 数据如何储存？

我计划只保存关注用户的数字 id，并且在页面启动时读取到内存中以备使用。

Pixiv 的用户 id 目前是 8 位数字，考虑到未来的变化，按照 10 位数字预估。（10 位数字是十亿级别，最大可以到 99 亿，够地球上所有人使用了）

### 存储到 localStorage

同一个站点下 localStorage 只能保存最多 5MB 数据。

目前 pixiv 在 localStorage 里存储的数据量比较少，我粗略翻看了以下，估计总共不会超过 100 KB。

如果仅考虑存储用户 id，那么是够用的。

如果一个用户 id 占用 10 Byte，大约可以储存 500,000 个用户 id。

潜在问题：

1. 有些用户喜欢清理缓存数据，这会导致储存的用户 id 被清空。（不过问题不大，因为重新获取一遍关注列表通常不会花费很久）
2. 在无痕模式下，需要重新获取关注列表。
3. 或许会有其他的扩展或脚本在 Pixiv 存储大量数据，导致 localStorage 空间不够用（这个可能性很低）。

### 存储到 IndexedDB

IndexedDB 的存储量很大，通常都是 GB 级别，存储关注列表的 id 肯定够用了。

潜在问题：

1. 有些用户喜欢清理缓存数据，这会导致储存的用户 id 被清空。（不过问题不大，因为重新获取一遍关注列表通常不会花费很久）
2. 在无痕模式下，需要重新获取关注列表。
3. IndexedDB 的 API 操作稍显复杂

### 储存到 chrome.storage.local

chrome.storage.local 的储存上限和 localStorage 相仿，是 5 MiB（5242880 Byte）。

它里面现在储存的有下载器的设置，以及下载时的一些任务数据。用它储存关注列表一般也够用。

而且 chrome.storage.local 里的数据更持久。它不仅不受清理缓存的影响，而且在无痕模式下里面的数据依然生效，这不同于其他两种方式。

### 总结

localStorage 和 IndexedDB 相比，主要区别在于可存储的数据体积不同。不过这项功能的数据体积不会太大，所以 localStorage 更好。 

而和 localStorage 相比，chrome.storage.local 的优势是数据不会因为清理缓存被删除，并且在无痕模式里也可以共用数据，不需要重新获取数据。

我倾向于使用 chrome.storage.local，但这需要考虑其他数据会占用多少空间。

现在有 3 种数据会存储在 chrome.storage.local 里：

1. 下载器的设置。这通常不会超过 10 KB。
2. background 里的 batchNo，体积很小，可以忽略不计。
3. background 里的 idList，有可能比较多。（当下载器处于下载途中时，这项数据会不断增多。当发起下载的标签页关闭后，下载器会清除该标签页所产生的这项数据）

主要是 idList，当前台页面发送下载任务时，后台页面会存储这个任务的 id。如果某个标签页里下载了非常多的文件（假设有 100,000 个），那么这些 id 粗略估计可能会占用 1 - 2 MB 空间。如果文件数量更多，那么占用的空间也会更多。

但是考虑到关注的用户数量通常只有几千个，按一万个算，只保存其 id，那么只占用约 100 KB 空间，所以放在 chrome.storage.local 里应该是没问题的。

目前暂定使用 chrome.storage.local 存储数据。

## 何时获取/更新关注列表？

### 定时检查更新

定时获取关注列表第一页的数据，如果关注总数 total 变化则通过 API 重新获取数据。

由于用户可以取消关注任意位置（索引）的用户，所以此时必须执行全量更新。

### 监听用户新增或取消关注的动作

如果用户点击关注或取消关注按钮时，下载器能够检测到这次操作的详细信息，则不必请求 API 来检查总数，而是直接操作在数据里添加或删除对应的 id 即可。

#### 方法 1：监听网络请求

应该可以使用 webRequest 权限达成目的。

https://developer.chrome.com/docs/extensions/reference/webRequest/#examples

先尝试是否可以实现。如果成功了，那么这个版本先不启用监听功能，也不增加 webRequest 权限，而是先提醒用户，下一次更新再添加这个权限，开启这个功能。

----------

当点击关注按钮时，API 为

```
https://www.pixiv.net/bookmark_add.php
```

需要注意，收藏一个作品后，点击作品下方的编辑收藏按钮，也会跳转到 `bookmark_add.php`。所以监听关注用户的请求时需要判断请求方法为 POST。

请求方法为 POST，Content-Type: application/x-www-form-urlencoded; charset=utf-8，body 如：

```
mode=add&type=user&user_id=89469319&tag=&restrict=0&format=json
```

```
mode: add
type: user
user_id: 89469319
tag: 
restrict: 0
format: json
```

对于下载器来说，必须获取 body，通过判断它的参数内容来确定用户的操作。

-------------------

点击取消关注按钮时，API 为 

```
https://www.pixiv.net/rpc_group_setting.php
```

请求方法为 POST，Content-Type: application/x-www-form-urlencoded; charset=utf-8，body 如：

```
mode=del&type=bookuser&id=89469319
```

```
mode: del
type: bookuser
id: 89469319
```

感觉这个 API 调用稍显怪异，可能是早期 API 一直保留到了现在。

#### 方法 2：检测按钮元素

这是个下策，相比监听网络请求，这个方法唯一的优点是不需要请求新权限，可以避免用户的担心。

但是这个方法先不说是否能实现，就算实现了，以后 Pixiv 页面元素改版也可能导致失效。

在作品页面内，页面右侧的作者的关注按钮的 html 代码如下：

```html
英语的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">Follow</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">Following</button>

日语的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">フォローする</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">フォロー中</button>

中文的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">加关注</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">已关注</button>
```

可以看出，在按钮为关注或取消关注时，只有两点不同：
1. 有一个 className 不同。未关注时按钮是蓝色，有个 `kmHafz`，关注后按钮是灰色，变成 `eLIyxB`。
2. 按钮文字不同。但是根据语言不同，文字也有多个版本，这也会造成麻烦。

除了这两个区别，无法得知点击这个按钮时的动作是关注还是取消关注。

并且在其他页面有不同类型的关注按钮，这也会使情况变得复杂。

目前还是考虑使用监听网络请求的方法。

## 清除长时间未使用的用户的数据

用户可能切换登录多个 pixiv 账号，所以下载器可能保存了多个账号的关注列表数据。

当某个账号没有更新时，下载器就不会检查其收藏数量，也就不会更新他数据里的 `time`。

当 `time` 一段时间未发生变化时，可以考虑清除这个账户的关注列表数据。
